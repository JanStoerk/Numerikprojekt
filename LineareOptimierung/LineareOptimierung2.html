<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Branch and Bound Visualisierung</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <style>
        #ggb-element {
            width: 100%;
            height: 800px;
            border: 1px solid lightgray;
        }
    </style>
</head>
<body>

<div id="ggb-element"></div>

<script type="text/javascript">
    class BranchAndBound {
        constructor(objectiveCoefficients, constraintsCoefficients, constraintsBounds) {
            this.bestSolution = null;
            this.bestObjectiveValue = -Infinity;
            this.objectiveCoefficients = objectiveCoefficients;
            this.constraintsCoefficients = constraintsCoefficients;
            this.constraintsBounds = constraintsBounds;
            this.numVariables = objectiveCoefficients.length;
            this.initialBounds = this.computeInitialBounds();
            this.nodes = new vis.DataSet([{ id: 1, label: `Max Z`, title: 'Startpunkt' }]);
            this.edges = new vis.DataSet([]);
            this.nodeIdCounter = 2; // Start with 2, since 1 is already used
            this.createTree();
        }

        computeInitialBounds() {
            let bounds = Array(this.numVariables).fill(null).map(() => [0, Infinity]);
            this.constraintsCoefficients.forEach((constraint, constraintIndex) => {
                constraint.forEach((coeff, varIndex) => {
                    if (coeff > 0 && varIndex < this.numVariables) {
                        const maxVal = Math.floor(this.constraintsBounds[constraintIndex] / coeff);
                        bounds[varIndex][1] = Math.min(bounds[varIndex][1], maxVal);
                    }
                });
            });
            return bounds.map(bound => [bound[0], isFinite(bound[1]) ? bound[1] : Math.floor(10 * this.objectiveCoefficients[bounds.length - 1])]);
        }

        evaluateObjective(solution) {
            return this.objectiveCoefficients.reduce((sum, coeff, index) => sum + coeff * solution[index], 0);
        }

        satisfiesConstraints(solution) {
            return this.constraintsCoefficients.every((coeffs, index) =>
                coeffs.reduce((sum, coeff, varIndex) =>
                    varIndex < solution.length ? sum + coeff * solution[varIndex] : sum, 0) <= this.constraintsBounds[index]
            );
        }

        solve(maxIterations) {
            let stack = [{ bounds: this.initialBounds, path: 'start', parentId: 1 }];
            let iterations = 0;

            while (stack.length > 0 && iterations < maxIterations) {
                const node = stack.pop();
                const bounds = node.bounds;
                const midpoint = bounds.map(([low, high]) => Math.floor((low + high) / 2));
                const nodeId = this.nodeIdCounter++;
                const label = `x = ${midpoint[0]}, y = ${midpoint[1]}`;
                this.nodes.add({ id: nodeId, label: label, title: `x = ${midpoint[0]}, y = ${midpoint[1]}` });

                let edgeOptions = { from: node.parentId, to: nodeId };
                
                if (this.explore(midpoint)) {
                    console.log(`Iteration ${iterations + 1}: Current best solution: ${JSON.stringify(this.bestSolution)}, Objective: ${this.bestObjectiveValue}`);
                } else {
                    // Mark the edge as pruned if it leads to an invalid solution
                    edgeOptions.color = 'red';
                    edgeOptions.dashes = true;
                }

                this.edges.add(edgeOptions);

                bounds.forEach((bound, index) => {
                    const [low, high] = bound;
                    const mid = midpoint[index];

                    if (low <= mid - 1) {
                        const newBounds = bounds.map((b, i) => i === index ? [low, mid - 1] : b);
                        stack.push({ bounds: newBounds, path: `${node.path} -> x${index + 1} <= ${mid - 1}`, parentId: nodeId });
                    }

                    if (mid + 1 <= high) {
                        const newBounds = bounds.map((b, i) => i === index ? [mid + 1, high] : b);
                        stack.push({ bounds: newBounds, path: `${node.path} -> x${index + 1} >= ${mid + 1}`, parentId: nodeId });
                    }
                });

                iterations++;
            }
        }

        explore(solution) {
            if (this.satisfiesConstraints(solution)) {
                const objectiveValue = this.evaluateObjective(solution);
                if (objectiveValue > this.bestObjectiveValue) {
                    this.bestObjectiveValue = objectiveValue;
                    this.bestSolution = [...solution];
                    return true;
                }
            }
            return false;
        }

        createTree() {
            const container = document.getElementById('ggb-element');
            const data = { nodes: this.nodes, edges: this.edges };

            const options = {
                layout: {
                    hierarchical: {
                        direction: "UD",
                        sortMethod: "directed"
                    }
                },
                physics: {
                    enabled: true,
                    hierarchicalRepulsion: {
                        avoidOverlap: 1,
                    },
                    stabilization: false,
                    minVelocity: 0.75,
                    solver: 'barnesHut',
                    barnesHut: {
                        springLength: 200,
                        avoidOverlap: 1
                    },
                    bounce: 0.5,
                    timestep: 0.5,
                },
                interaction: {
                    dragView: false,
                    zoomView: false,
                    dragNodes: false
                },
                nodes: {
                    shape: 'circle',
                    size: 30,
                    font: {
                        size: 14,
                        color: '#ffffff',
                    },
                    borderWidth: 2,
                },
                edges: {
                    arrows: { to: { enabled: true } }
                },
                manipulation: {
                    enabled: false,
                    initiallyActive: true
                }
            };

            new vis.Network(container, data, options);
        }
    }

    const objectiveCoefficients = [3, 4];
    const constraintsCoefficients = [
        [1, 1],
        [1, 0],
        [0, 1]
    ];
    const constraintsBounds = [5, 3, 2];

    const maxIterations = 10;

    const bbSolver = new BranchAndBound(objectiveCoefficients, constraintsCoefficients, constraintsBounds);
    bbSolver.solve(maxIterations);

    console.log('Final Best Solution:', JSON.stringify(bbSolver.bestSolution));
    console.log('Final Best Objective Value:', bbSolver.bestObjectiveValue);
</script>

</body>
</html>
