<!doctype html>
<html>

<head>
    <link rel="stylesheet" href="../LandingPage/style.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.min.js"></script>

    <meta charset="UTF-8">
</head>

<body>
    <header class="header">
        <div class="brand">
            <a href="../LandingPage/index.html" style="color:white;" class="link">
                <img src="../pictures/infinite.png" style="width:50px; height:30px; align-self: center;" alt="Numerik">
                <h1>Numerik</h1>
            </a>
        </div>
        <button class="guide" onclick="showGuide()">
            <img src="../pictures/guide.png" style="width:30px" alt="Guide">
            <h4>Guide</h4>
        </button>
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closePopup()">&times;</span>
                <p>das Branch-and-Bound-Verfahren kann sehr schnell zu einer gro√üen Anzahl von Knoten und damit zu einem
                    gro√üen Baum f√ºhren, insbesondere wenn die Dimension des Problems oder die Anzahl der Variablen
                    steigt. Dies liegt an der Natur des Verfahrens, das darauf basiert, den L√∂sungsraum rekursiv in
                    kleinere Teilr√§ume (Teilprobleme) zu unterteilen und zu pr√ºfen.
                    Warum w√§chst der Baum so schnell?
                    Exponentielles Wachstum:

                    Bei jedem Schritt wird der L√∂sungsraum in zwei oder mehr Teilr√§ume unterteilt. Bei
                    ùëõ
                    n Variablen und
                    ùëè
                    b m√∂glichen Grenzen pro Variable k√∂nnen im schlimmsten Fall bis zu
                    ùëè
                    ùëõ
                    b
                    n
                    Knoten im Baum entstehen. Das bedeutet, dass die Anzahl der Knoten exponentiell mit der Anzahl der
                    Variablen und den m√∂glichen Grenzen ansteigt.
                    Verzweigung in jede Richtung:

                    F√ºr jede Variable wird in beide Richtungen (kleinere und gr√∂√üere Werte) verzweigt, um alle m√∂glichen
                    L√∂sungen zu erkunden. Dies f√ºhrt dazu, dass der Baum schnell sehr breit und tief wird.
                    Zahlreiche Begrenzungen und Einschr√§nkungen:

                    Wenn das Problem viele Einschr√§nkungen hat, k√∂nnte das Verfahren viele M√∂glichkeiten erkunden, bevor
                    es die optimalen Werte findet. Dies erh√∂ht ebenfalls die Anzahl der Knoten.</p>
            </div>
        </div>
    </header>
    <script>
        function showGuide() {
            var modal = document.getElementById("myModal");
            modal.style.display = "block";
            document.addEventListener("keydown", closeOnEscape);
        }

        function closePopup() {
            var modal = document.getElementById("myModal");
            modal.style.display = "none";
            document.removeEventListener("keydown", closeOnEscape);
        }

        function closeOnEscape(event) {
            if (event.key === "Escape") {
                closePopup();
            }
        }
    </script>
    <div class="content">
        <h4><b>Lineare Optimierung: Branch & Bound Verfahren</b><button class="fa fa-info-circle" onclick="showGuide()"
                style="font-size:24px; margin-left: 10px; color:grey; border:0; background-color: transparent;"></button>
        </h4><br>
        <div style="display: flex; justify-content: space-around; align-items: center;">
            <div style="flex: 1; text-align: center;">
                <table style="margin: auto;" class="table table-hover" id="nebenbedingungen">
                    <tbody>
                        <tr>
                            <td><label for="funktion">Maximierungsproblem</label></td>
                            <td><input type="text" id="funktion"></td>
                        </tr>
                        <tr>
                            <td><label for="untereGrenze">Nebenbedingung 1</label></td>
                            <td><input type="text" id="nebenbedingung1"></td>
                        </tr>
                        <tr>
                            <td><label for="obereGrenze">Nebenbedingung 2</label></td>
                            <td><input type="text" id="nebenbedingung2"></td>
                        </tr>
                    </tbody>
                </table>
                <br>
                <button id="btnZeichne" class="btn btn-secondary">Nebenbedingung hinzuf√ºgen</button> <br><br>
                <script>

                    document.addEventListener('DOMContentLoaded', function () {
                        const maxNebenbedingungen = 9;
                        const nebenbedingungenTable = document.getElementById('nebenbedingungen');
                        const btnZeichne = document.getElementById('btnZeichne');
                        let nebenbedingungCount = 2;

                        btnZeichne.addEventListener('click', function () {
                            if (nebenbedingungCount < maxNebenbedingungen) {
                                nebenbedingungCount++;
                                const neueZeile = document.createElement('tr');
                                neueZeile.innerHTML = `
                                    <td><label for="nebenbedingung${nebenbedingungCount}">Nebenbedingung ${nebenbedingungCount}</label></td>
                                    <td><input type="text" id="nebenbedingung${nebenbedingungCount}"></td>
                                `;
                                nebenbedingungenTable.querySelector('tbody').appendChild(neueZeile);
                            } else if (nebenbedingungCount = maxNebenbedingungen) {
                                nebenbedingungCount++;
                                const neueZeile = document.createElement('tr');
                                neueZeile.innerHTML = `
                                    <td><label for="nebenbedingung${nebenbedingungCount}">Nebenbedingung ${nebenbedingungCount}</label></td>
                                    <td><input type="text" id="nebenbedingung${nebenbedingungCount}"></td>
                                `;
                                nebenbedingungenTable.querySelector('tbody').appendChild(neueZeile);
                                btnZeichne.disabled = true;
                            }
                        });
                    });
                </script>
                <div class="controls">
                    <div style="margin:auto; display:flex">
                        <button id="skip-back" onclick="stepwiseChange(-1)">
                            <i class="fas fa-backward"></i>
                        </button>
                        <button id="btnStart" style="margin-inline: 20px;">
                            <i class="fas fa-play" id="play-icon"></i>
                            <i class="fas fa-pause" id="pause-icon" style="display: none;"></i>
                        </button>
                        <button id="skip-forward">
                            <i class="fas fa-forward"></i>
                        </button>
                    </div>
                </div>
                <br>
                <!-- <input type="checkbox" style="margin-top: 10px;" id="myCheckbox" class="form-check-input"> <label
                    id="checkboxLabel" for="myCheckbox">Bin√§res Problem</label> -->
            </div>
            <div>
                <div style="display: flex; align-items: center; justify-content: center;">
                    <span class="badge rounded-pill bg-primary">G√ºltige L√∂sung</span>
                    <span class="badge rounded-pill bg-danger">Ung√ºltige L√∂sung</span>
                    <!--  <span class="badge rounded-pill bg-warning text-dark">Momentan beste L√∂sung</span>-->
                    <span class="badge rounded-pill bg-dark">Verworfener Teilbaum</span>
                </div>
                <div id="ggb-element"
                    style="flex: 1; text-align: center; margin: auto; height:600px; width:600px; border:1px solid black"></div>
                <div class="slider-container"
                    style="width: 600px; display: flex; flex-direction: column; align-items: center;">

                </div>
            </div>
            <div style="flex: 1; text-align: center; margin-left:30px">
                <button id="branchButton" class="btn btn-secondary">Baum
                    erstellen</button><br>
                <table style="margin: auto;" class="table table-hover" id="nebenbedingungen">
                    <tbody>
                        <tr>
                            <td><label for="funktion">Obere Schranke</label></td>
                            <td><label id="obereSchranke"></td>
                        </tr>
                        <tr>
                            <td><label for="untereGrenze">Untere Schranke</label></td>
                            <td><label id="untereSchranke"></td>
                        </tr>
                        <tr>
                            <td><label for="obereGrenze">Momentan beste L√∂sung</label></td>
                            <td><label id="momentanesErgebnis"></td>
                        </tr>
                        <tr>
                            <td><label for="obereGrenze">Ergebnis</label></td>
                            <td><label id="optimalesErgebnis"></td>
                        </tr>
                        <tr>
                            <td><label for="obereGrenze">Anzahl weiterer m√∂glicher L√∂sungen</label></td>
                            <td><label id="anzahlLoesungen"></td>
                        </tr>
                        <tr>
                            <td><label for="obereGrenze">Anzahl verworfener Teilb√§ume</label></td>
                            <td><label id="prunedTrees"></td>
                        </tr>
                    </tbody>
                </table>
                <div id="resultContainer"></div><br>
                <canvas id="abweichungsHistogramm"></canvas><br>
            </div>
        </div>
        <script type="text/javascript">


            class BranchAndBound {
                constructor(objectiveCoefficients, constraintsCoefficients, constraintsBounds, fx) {
                    this.bestSolution = null;
                    this.bestObjectiveValue = -Infinity;
                    this.objectiveCoefficients = objectiveCoefficients;
                    this.constraintsCoefficients = constraintsCoefficients;
                    this.constraintsBounds = constraintsBounds;
                    this.numVariables = objectiveCoefficients.length;
                    this.initialBounds = this.computeInitialBounds();
                    this.nodes = new vis.DataSet([{ id: 1, label: `Max ` + fx, title: 'Startpunkt' }]);
                    this.edges = new vis.DataSet([]);
                    this.nodeIdCounter = 2;
                    this.lowerBound = Infinity;
                    this.possibleSolutions = 0;
                    this.globalUpperBound = Infinity;
                    this.prunedTreeCount = 0;
                    this.stack = [{ bounds: this.initialBounds, path: 'start', parentId: 1 }];
                    this.iterations = 0;
                    this.maxIterations = 100;
                    this.createTree();
                    this.network;
                    this.bestNodeId = 0;
                }

                computeInitialBounds() {
                    let bounds = Array(this.numVariables).fill(null).map(() => [0, Infinity]);
                    this.constraintsCoefficients.forEach((constraint, constraintIndex) => {
                        constraint.forEach((coeff, varIndex) => {
                            if (coeff > 0 && varIndex < this.numVariables) {
                                const maxVal = Math.floor(this.constraintsBounds[constraintIndex] / coeff);
                                bounds[varIndex][1] = Math.min(bounds[varIndex][1], maxVal);
                            }
                        });
                    });
                    return bounds.map(bound => [bound[0], isFinite(bound[1]) ? bound[1] : Math.floor(10 * this.objectiveCoefficients[bounds.length - 1])]);
                }

                evaluateObjective(solution) {
                    return this.objectiveCoefficients.reduce((sum, coeff, index) => sum + coeff * solution[index], 0);
                }


                calculateUpperBound(bounds) {
                    const upperBound = bounds.reduce((sum, [low, high], index) => sum + high * this.objectiveCoefficients[index], 0);
                    return upperBound;
                }


                solve(maxIterations) {
                    while (this.stack.length > 0 && this.iterations < this.maxIterations) {
                        this.iterate();
                    }
                }

                satisfiesConstraints(solution) {
                    console.log(solution)
                    const allSatisfied = this.constraintsCoefficients.every((coeffs, index) => {

                        const lhs = coeffs.reduce((sum, coeff, varIndex) =>
                            sum + coeff * solution[varIndex], 0);
                        const satisfied = lhs <= this.constraintsBounds[index];
                        console.log(`Constraint ${index}: ${lhs} <= ${this.constraintsBounds[index]} -> ${satisfied}`);
                        return satisfied;
                    });
                    console.log("AllSatisfied: "+allSatisfied)
                    return allSatisfied;
                }

                iterate() {
                    if (this.stack.length === 0 || this.iterations >= this.maxIterations) {
                        this.network.fit({
                            animation: {
                                duration: 1000,
                                easingFunction: "easeInOutQuad"
                            }
                        });
                        return true;
                    }

                    const node = this.stack.pop();
                    const bounds = node.bounds;

                    const currentNode = this.nodes.get(node.parentId);
                    if (currentNode && currentNode.color && currentNode.color.background === '#4d4848') {
                        console.log(`Abbrechen: Parent Node ${node.parentId} ist schwarz.`);
                        return "pruned"; // Funktion beenden, wenn die Parent-Node schwarz ist
                    }

                    const midpoint = bounds.map(([low, high]) => Math.floor((low + high) / 2));
                    const nodeId = this.nodeIdCounter++;
                    const label = midpoint.map((value, index) => `x${index + 1} = ${value}`).join(', ');
                    const keyValuePairs = midpoint.map((value) => [value]);
                    this.nodes.add({ id: nodeId, label: label, title: label });

                    let edgeOptions = { from: node.parentId, to: nodeId };

                    var upperBound = this.calculateUpperBound(bounds);
                    if (this.explore(midpoint)) {
                        /*edgeOptions.color = { color: '#948715' };
                        edgeOptions.color.highlight = '#948715';
                        edgeOptions.color.hover = '#948715';
                        this.nodes.update({
                            id: nodeId,
                            color: {
                                background: '#c9bd4b',
                                border: '#948715',
                                highlight: {
                                    background: '#c9bd4b',
                                    border: '#948715'
                                },
                                hover: {
                                    background: '#c9bd4b',
                                    border: '#948715'
                                }
                            }
                        });*/
                        console.log(`Iteration ${this.iterations + 1}: Current best solution: ${JSON.stringify(this.bestSolution)}, Objective: ${this.bestObjectiveValue}`);
                    } else if (upperBound <= this.bestObjectiveValue) {
                        edgeOptions.color = { color: 'black' };
                        edgeOptions.dashes = true;
                        edgeOptions.color.highlight = 'black';
                        edgeOptions.color.hover = 'black';
                        this.nodes.update({
                            id: nodeId,
                            color: {
                                background: '#4d4848',
                                border: '#000000',
                                highlight: {
                                    background: '#4d4848',
                                    border: '#000000'
                                },
                                hover: {
                                    background: '#4d4848',
                                    border: '#000000'
                                }
                            }
                        });
                        this.prunedTreeCount++;
                    }
                    else if (!this.satisfiesConstraints(keyValuePairs)) {
                        edgeOptions.color = { color: 'red' };
                        edgeOptions.color.highlight = 'red';
                        edgeOptions.color.hover = 'red';
                        this.nodes.update({
                            id: nodeId,
                            color: {
                                background: '#ffcccc',
                                border: '#ff0000',
                                highlight: {
                                    background: '#ffcccc',
                                    border: '#ff0000'
                                },
                                hover: {
                                    background: '#ffcccc',
                                    border: '#ff0000'
                                }
                            }
                        });
                    }else{
                        edgeOptions.color = { color: 'blue' };
                        edgeOptions.color.highlight = 'blue';
                        edgeOptions.color.hover = 'blue';
                    }

                    this.edges.add(edgeOptions);

                    this.network.focus(nodeId, {
                        scale: 1.5,
                        animation: {
                            duration: 1000,
                            easingFunction: "easeInOutQuad"
                        }
                    });

                    bounds.forEach((bound, index) => {
                        const [low, high] = bound;
                        const mid = midpoint[index];

                        if (low <= mid - 1) {
                            const newBounds = bounds.map((b, i) => i === index ? [low, mid - 1] : b);
                            this.stack.push({ bounds: newBounds, path: `${node.path} -> x${index + 1} <= ${mid - 1}`, parentId: nodeId });
                        }

                        if (mid + 1 <= high) {
                            const newBounds = bounds.map((b, i) => i === index ? [mid + 1, high] : b);
                            this.stack.push({ bounds: newBounds, path: `${node.path} -> x${index + 1} >= ${mid + 1}`, parentId: nodeId });
                        }
                    });

                    this.iterations++;
                    this.lowerBound = Math.min(this.lowerBound, this.evaluateObjective(midpoint));
                    this.possibleSolutions = this.stack.length;

                    this.globalUpperBound = Math.max(this.globalUpperBound, upperBound);
                }


                explore(solution) {
                    if (this.satisfiesConstraints(solution)) {
                        const objectiveValue = this.evaluateObjective(solution);
                        if (objectiveValue > this.bestObjectiveValue) {
                            this.bestObjectiveValue = objectiveValue;
                            this.bestSolution = [...solution];
                            return true;
                        }
                    }
                    return false;
                }

                createTree() {
                    const container = document.getElementById('ggb-element');
                    const data = { nodes: this.nodes, edges: this.edges };

                    const options = {
                        layout: {
                            hierarchical: {
                                direction: "UD",
                                sortMethod: "directed"
                            }
                        },
                        physics: {
                            enabled: true,
                            hierarchicalRepulsion: {
                                avoidOverlap: 1,
                                nodeDistance: 100
                            },
                            stabilization: {
                                iterations: 1000,
                                updateInterval: 25
                            },
                            minVelocity: 0.1,
                            solver: 'barnesHut',
                            barnesHut: {
                                springLength: 200,
                                avoidOverlap: 1
                            },
                            bounce: 0.1,
                            timestep: 0.5
                        },
                        interaction: {
                            dragView: true,
                            zoomView: true,
                            dragNodes: false
                        },
                        nodes: {
                            shape: 'circle',
                            size: 30,
                            font: {
                                size: 14,
                                color: '#ffffff',
                            },
                            borderWidth: 2,
                        },
                        edges: {
                            arrows: { to: { enabled: true } }
                        },
                        manipulation: {
                            enabled: false
                        }
                    };

                    this.network = new vis.Network(container, data, options);
                }
            }

            var allVariables = ['x', 'y'];

            function parseObjectiveFunction(lhs) {
                const regex = /([+-]?\d*\.?\d*)([a-zA-Z]+)/g;
                let match;
                const coefficients = [];
                const variables = [];

                while ((match = regex.exec(lhs)) !== null) {
                    const coefficient = parseFloat(match[1]) || (match[1] === '-' ? -1 : 1);
                    const variable = match[2];
                    coefficients.push(coefficient);
                    variables.push(variable);
                }
                return { coefficients, variables };
            }


            function parseConstraint(input) {

                input = input.replace(/\s+/g, '');

                const [lhs, rhs] = input.split('<=');
                const { coefficients, variables } = parseObjectiveFunction(lhs);

                const filledCoefficients = new Array(allVariables.length).fill(0);

                variables.forEach((variable, index) => {
                    const varIndex = allVariables.indexOf(variable);
                    if (varIndex !== -1) {
                        filledCoefficients[varIndex] = coefficients[index];
                    }
                });

                const bound = parseFloat(rhs);
                return { coefficients: filledCoefficients, variables: allVariables, bound };
            }

            document.addEventListener('DOMContentLoaded', function () {
                const btnStart = document.getElementById('branchButton');
                const skipForwardButton = document.getElementById('skip-forward');
                const playButton = document.getElementById('btnStart');
                const skipBackwardButton = document.getElementById('skip-back');
                const addConditionBtn = document.getElementById('addConditionBtn');
                let conditionCount = 3;
                let bbSolver = null;
                var nebenbedingungen = [];
                var constraintsCoefficients = [];
                var constraintsBounds = [];
                var coefficients = []
                var funktion = "";
                let stopFunction = false;

                function getInputs() {
                    funktion = document.getElementById('funktion').value.trim().replace(/\s+/g, '');
                    funktion = funktion.replace(',', '.');
                    var parsedFunction = parseObjectiveFunction(funktion);
                    coefficients = parsedFunction.coefficients;
                    allVariables = parsedFunction.variables;
                    console.log("Alle Variablen in der Funktion: " + allVariables)
                    for (let i = 1; i <= conditionCount; i++) {
                        const input = document.getElementById('nebenbedingung' + i);
                        if (input && input.value) {
                            nebenbedingungen.push(input.value);
                            constraintsCoefficients.push(parseConstraint(input.value).coefficients)
                            constraintsBounds.push(parseConstraint(input.value).bound)
                        }
                    }
                }

                btnStart.addEventListener('click', function () {

                    getInputs()

                    const maxIterations = 100;

                    bbSolver = new BranchAndBound(coefficients, constraintsCoefficients, constraintsBounds, funktion);
                    bbSolver.solve(maxIterations);

                    updateResults(bbSolver);
                });

                skipForwardButton.addEventListener('click', function () {
                    if (bbSolver) {
                        bbSolver.iterate();
                        updateResults(bbSolver);
                    } else {
                        getInputs()
                        bbSolver = new BranchAndBound(coefficients, constraintsCoefficients, constraintsBounds, funktion);
                        bbSolver.iterate();
                        updateResults(bbSolver);
                    }
                });

                playButton.addEventListener('click', async () => {
                    stopFunction = false;
                    if (!bbSolver) {
                        getInputs()
                        bbSolver = new BranchAndBound(coefficients, constraintsCoefficients, constraintsBounds, funktion);
                    }
                    var i = 0;
                    while (i < 100) {
                        if (stopFunction) {
                            break;
                        }
                        i++;
                        var end = bbSolver.iterate();
                        updateResults(bbSolver);
                        if (end == true) {
                            break;
                        }
                        if(end != "pruned") await new Promise(resolve => setTimeout(resolve, 1000));
                        
                    }
                });

                skipBackwardButton.addEventListener('click', function () {
                    
                });

                function updateResults(bbSolver) {
                    const obereSchrankeInput = document.getElementById('obereSchranke');
                    const untereSchrankeInput = document.getElementById('untereSchranke');
                    const momentanesErgebnisLabel = document.getElementById('momentanesErgebnis');
                    const optimalesErgebnisLabel = document.getElementById('optimalesErgebnis');
                    const anzahlLoesungenLabel = document.getElementById('anzahlLoesungen');
                    const prunedTrees = document.getElementById('prunedTrees');

                    obereSchrankeInput.innerHTML = bbSolver.bestObjectiveValue;
                    untereSchrankeInput.innerHTML = bbSolver.lowerBound;
                    momentanesErgebnisLabel.innerHTML = JSON.stringify(bbSolver.bestSolution);
                    optimalesErgebnisLabel.innerHTML = bbSolver.bestObjectiveValue;
                    anzahlLoesungenLabel.innerHTML = bbSolver.possibleSolutions;
                    prunedTrees.innerHTML = bbSolver.prunedTreeCount;
                }

                window.addEventListener('blur', () => {
                stopFunction = true;
            });
            });

            
        </script>

</body>

</html>